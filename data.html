<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Innovatoor Data Flow</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #0e010f;
            font-family: 'Segoe UI', system-ui, Arial;
            overflow: hidden;
        }
        
        .data-header {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }
        
        #binary-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }
        
        #data-canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 2;
        }
        
        .sprite-hint {
            position: absolute;
            left: 50%;
            bottom: 20px;
            transform: translateX(-50%);
            font-size: 13px;
            color: #ffffff;
            opacity: .9;
            z-index: 12;
            pointer-events: none;
            text-shadow: 0 2px 8px rgba(116, 54, 187, 0.5);
            text-align: center;
            padding: 0 10px;
        }
        
        .info-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(61, 15, 65, 0.95);
            border: 2px solid #0e010f;
            border-radius: 16px;
            padding: 28px 32px;
            color: #fff;
            z-index: 60;
            max-width: 820px;
            width: calc(100% - 40px);
            box-shadow: 0 20px 80px rgba(0, 0, 0, 0.8), 0 0 30px rgba(116, 54, 187, 0.3);
            opacity: 0;
            pointer-events: none;
            transition: opacity .3s, transform .3s;
            backdrop-filter: blur(12px);
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .info-panel.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translate(-50%, -50%) scale(1);
        }
        
        .info-panel h2 {
            margin: 0 0 12px 0;
            font-size: 1.6rem;
            color: #fff;
            font-weight: 600;
        }
        
        .info-panel p {
            margin: 0;
            color: #e8e8e8;
            line-height: 1.6;
            font-size: 0.95rem;
        }
        
        .info-panel .close-btn {
            position: absolute;
            top: 12px;
            right: 16px;
            background: rgba(116, 54, 187, 0.2);
            border: 1px solid rgba(116, 54, 187, 0.5);
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .info-panel .close-btn:hover {
            background: rgba(116, 54, 187, 0.4);
            border-color: #7436bb;
        }
        /* ===== INNOVATOOR CENTER OVERLAY ===== */
        
        .innovatoor-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: radial-gradient( circle, rgba(116, 54, 187, 0.65), rgba(61, 15, 65, 0.95));
            border: 2px solid #7436bb;
            box-shadow: 0 0 60px rgba(116, 54, 187, 0.9), inset 0 0 35px rgba(0, 0, 0, 0.6);
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            pointer-events: none;
        }
        
        .innovatoor-title {
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 1px;
            color: #ffffff;
        }
        
        .innovatoor-services {
            margin-top: 8px;
            font-size: 11px;
            line-height: 1.4;
            color: #e6d9ff;
        }
        /* ===== MOBILE ===== */
        
        @media (max-width: 768px) {
            .innovatoor-center {
                width: 120px;
                height: 120px;
            }
            .innovatoor-title {
                font-size: 13px;
            }
            .innovatoor-services {
                font-size: 8px;
            }
            .sprite-hint {
                font-size: 11px;
                bottom: 15px;
            }
        }
        
        @media (max-width: 480px) {
            .innovatoor-center {
                width: 100px;
                height: 100px;
            }
            .innovatoor-title {
                font-size: 12px;
            }
            .innovatoor-services {
                font-size: 7px;
            }
        }
        
        @media(max-width:768px) {
            .info-panel {
                max-width: 92%;
                padding: 20px;
            }
            .info-panel h2 {
                font-size: 1.2rem;
            }
            .info-panel p {
                font-size: 0.9rem;
            }
        }
        
        @media(max-width:480px) {
            .info-panel {
                padding: 16px;
            }
            .info-panel h2 {
                font-size: 1.1rem;
                margin-bottom: 10px;
            }
            .info-panel p {
                font-size: 0.85rem;
            }
        }
    </style>
</head>

<body>
    <div class="data-header" id="dataHeader">
        <canvas id="binary-background"></canvas>
        <canvas id="data-canvas" aria-label="Data flow visualization"></canvas>

        <div class="innovatoor-center">
            <div class="innovatoor-title">INNOVATOOR</div>
            <div class="innovatoor-services">
                <b>Services</b>
            </div>
        </div>

        <div class="sprite-hint">Click service labels to learn more</div>

        <div class="info-panel" id="info-panel" role="dialog" aria-hidden="true">
            <button class="close-btn" onclick="closePanel()" aria-label="Close">Ã—</button>
            <div id="info-content"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // Binary Background Animation - Grid pattern
        (function() {
            const canvas = document.getElementById('binary-background');
            const ctx = canvas.getContext('2d');

            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            resize();
            window.addEventListener('resize', resize);

            const fontSize = 14;
            const columns = Math.floor(canvas.width / fontSize);
            const rows = Math.floor(canvas.height / fontSize);

            // Create grid of binary digits
            const grid = [];
            for (let i = 0; i < columns; i++) {
                grid[i] = [];
                for (let j = 0; j < rows; j++) {
                    grid[i][j] = {
                        value: Math.random() > 0.5 ? '1' : '0',
                        opacity: Math.random() * 0.5 + 0.1,
                        changeSpeed: Math.random() * 0.02
                    };
                }
            }

            function drawBinary() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.font = `${fontSize}px monospace`;

                for (let i = 0; i < columns; i++) {
                    for (let j = 0; j < rows; j++) {
                        const cell = grid[i][j];

                        // Randomly change some digits
                        if (Math.random() < cell.changeSpeed) {
                            cell.value = Math.random() > 0.5 ? '1' : '0';
                            cell.opacity = Math.random() * 0.5 + 0.3;
                        } else {
                            cell.opacity *= 0.98;
                            if (cell.opacity < 0.1) cell.opacity = 0.1;
                        }

                        // Purple gradient
                        const alpha = cell.opacity;
                        ctx.fillStyle = `rgba(116, 54, 187, ${alpha})`;
                        ctx.fillText(cell.value, i * fontSize, j * fontSize);
                    }
                }
            }

            setInterval(drawBinary, 50);
        })();

        // Main 3D Visualization
        (function() {
            try {
                const services = [
                    "Data Warehouse",
                    "Market Research",
                    "Competitor Analysis",
                    "OSINT",
                    "Data Integration",
                    "Due Diligence",
                    "Data scraping"
                ];

                const descriptions = {
                    "Data Warehouse": "The Innovatoor Data Warehouse is an intelligence-focused software platform designed to bring clarity to complex markets.<br> It centralizes large volumes of publicly available data into one structured and continuously updated system, removing the need for manual research, scattered spreadsheets, and fragmented information sources. <br>The platform automatically collects data from websites, news outlets, company directories, digital platforms, and other open sources, ensuring decision-makers always work with fresh and reliable intelligence.<br><br>For competitor analysis, the Innovatoor Data Warehouse enables organizations to clearly identify key market players and understand how competitors operate and evolve. It allows you to track competitors' online visibility, media mentions, partnerships, business activities, and growth signals over time. <br>For example, a company planning to enter a new market can instantly see who is already active, which players are gaining influence, and where strategic gaps exist.<br><br>By combining advanced OSINT methodologies with automated data collection and structured storage, the Innovatoor Data Warehouse transforms raw public data into actionable insights. It supports faster decision-making, reduces strategic and operational risk, and helps organizations position themselves ahead of the competition with confidence.",

                    "Market Research": " Understand your market before your competitors do. <br>Our market research and competitor analysis services provide a clear view of industry dynamics, customer behavior, pricing structures, and competitive positioning. <br>We combine data collection, OSINT techniques,and analytical insights to help you identify gaps, validate opportunities, reduce uncertainty, and build strategies grounded in evidence not assumptions.",

                    "Competitor Analysis": "Innovatoor's Competitor Analysis service helps organizations clearly understand their competitive landscape using data-driven intelligence rather than assumptions. <br><br>We identify who your real competitors are, how they position themselves, and how their strategies evolve over time.<br><br>Using OSINT techniques and automated data collection, we track competitors' digital presence, media visibility, partnerships, and market activity. For example, a company planning to launch a new service can quickly see existing players, evaluate their strengths and weaknesses, and identify gaps in the market.<br><br>This approach transforms publicly available information into actionable insights, enabling smarter strategic decisions, reduced market risk, and stronger competitive positioning.",

                    "OSINT": " Make smarter, safer decisions with intelligence that goes beyond surface-level information. <br>Our Open Source Intelligence (OSINT) services uncover hidden digital footprints, verify identities, expose risks, and reveal opportunities across people, companies, and markets. <br>Whether you are assessing partners, investigating fraud, monitoring reputational threats, or preparing strategic moves, we transform scattered public data into clear, actionable intelligence you can trust.",

                    "Data Integration": "The world is changing and unpredictable, sometimes you don't know where to invest how to invest or the return on the investment.<br><br> You don't know if you should start a business today, tomorrow or the following year, you don't know the taste of the people in your loacality.<br><br> If you are already an existing startup you don't know the trend of the market, you are confused either you should look for investors or an IPO.<br> At Innovatoor we offer you the answer to this, wherever your country is and whatever the nature of your business. With advanced softwares and analysis.<br> We offer: OSINT,Market research, Competitor analysis",

                    "Due Diligence": " Reduce risk before it becomes costly. <br>Our due diligence services provide in-depth background checks and risk assessments on individuals, companies, and transactions.<br> <br>We analyze ownership structures, digital presence, reputational signals, operational history, and red flags using OSINT and data-driven methodologies. <br><br>This enables you to enter partnerships, investments, or acquisitions with confidence and clarity",

                    "Data scraping": "Access the data that drives real business decisions automatically and at scale.<br> <br>We design and deploy advanced data scraping bots that collect structured, reliable information from multiple online sources, even where manual collection is impossible or time consuming.<br><br> From market prices, company records, and online listings to news, trends, and lead databases, we deliver clean, ready-to-use data that powers analysis, monitoring, and growth."
                };

                const canvas = document.getElementById('data-canvas');
                const scene = new THREE.Scene();

                // Adjust camera FOV and position based on screen size
                let isMobile = window.innerWidth < 768;
                const fov = isMobile ? 90 : 75;
                const camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 0, isMobile ? 35 : 30);

                const renderer = new THREE.WebGLRenderer({
                    canvas,
                    antialias: true,
                    alpha: true
                });
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x000000, 0);

                // Lighting
                scene.add(new THREE.AmbientLight(0xffffff, 0.3));
                const light1 = new THREE.PointLight(0x7436bb, 2, 100);
                light1.position.set(20, 20, 20);
                scene.add(light1);
                const light2 = new THREE.PointLight(0x3d0f41, 1.5, 100);
                light2.position.set(-20, -20, 20);
                scene.add(light2);

                const dataGroup = new THREE.Group();
                scene.add(dataGroup);

                // Create tunnel-like structure with data streams
                const streamCount = 12;
                const segmentsPerStream = 100;
                const tunnelDepth = 60;
                const baseRadius = 8;

                const allNodes = [];
                const connections = [];
                const dataPackets = [];

                // Create radiating streams
                for (let s = 0; s < streamCount; s++) {
                    const angle = (s / streamCount) * Math.PI * 2;
                    const streamNodes = [];

                    for (let i = 0; i < segmentsPerStream; i++) {
                        const t = i / segmentsPerStream;
                        const z = -tunnelDepth / 2 + t * tunnelDepth;

                        // Perspective effect - wider at front, narrower at back
                        const radiusMultiplier = 1 - t * 0.7;
                        const radius = baseRadius * radiusMultiplier;

                        // Add some wave motion
                        const wave = Math.sin(t * Math.PI * 4) * 0.5;
                        const x = Math.cos(angle) * (radius + wave);
                        const y = Math.sin(angle) * (radius + wave);

                        // Create node
                        const nodeGeom = new THREE.SphereGeometry(0.08, 8, 8);
                        const nodeMat = new THREE.MeshPhongMaterial({
                            color: 0x7436bb,
                            emissive: 0x3d0f41,
                            emissiveIntensity: 0.4,
                            transparent: true,
                            opacity: 0.6
                        });
                        const node = new THREE.Mesh(nodeGeom, nodeMat);
                        node.position.set(x, y, z);
                        dataGroup.add(node);

                        streamNodes.push({
                            mesh: node,
                            position: new THREE.Vector3(x, y, z)
                        });
                        allNodes.push({
                            mesh: node,
                            position: new THREE.Vector3(x, y, z)
                        });

                        // Connect to previous node in stream
                        if (i > 0) {
                            const prev = streamNodes[i - 1];
                            const geometry = new THREE.BufferGeometry().setFromPoints([
                                prev.position,
                                new THREE.Vector3(x, y, z)
                            ]);
                            const material = new THREE.LineBasicMaterial({
                                color: 0x7436bb,
                                transparent: true,
                                opacity: 0.3
                            });
                            const line = new THREE.Line(geometry, material);
                            dataGroup.add(line);
                            connections.push({
                                line,
                                start: prev.position,
                                end: new THREE.Vector3(x, y, z)
                            });
                        }
                    }

                    // Connect streams to adjacent streams for interconnection
                    if (s > 0) {
                        const prevStream = allNodes.slice((s - 1) * segmentsPerStream, s * segmentsPerStream);
                        for (let i = 0; i < Math.min(20, segmentsPerStream); i += 5) {
                            const idx = Math.floor(i);
                            if (streamNodes[idx] && prevStream[idx]) {
                                const geometry = new THREE.BufferGeometry().setFromPoints([
                                    streamNodes[idx].position,
                                    prevStream[idx].position
                                ]);
                                const material = new THREE.LineBasicMaterial({
                                    color: 0x3d0f41,
                                    transparent: true,
                                    opacity: 0.15
                                });
                                const line = new THREE.Line(geometry, material);
                                dataGroup.add(line);
                            }
                        }
                    }
                }

                // Create flowing data packets
                for (let i = 0; i < 80; i++) {
                    const geom = new THREE.SphereGeometry(0.15, 12, 12);
                    const mat = new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        emissive: 0x7436bb,
                        emissiveIntensity: 0.8,
                        transparent: true,
                        opacity: 0.95
                    });
                    const packet = new THREE.Mesh(geom, mat);
                    dataGroup.add(packet);

                    const streamIdx = Math.floor(Math.random() * streamCount);
                    dataPackets.push({
                        mesh: packet,
                        progress: Math.random(),
                        speed: (isMobile ? 0.006 : 0.003) + Math.random() * (isMobile ? 0.006 : 0.004),

                        streamIndex: streamIdx,
                        segmentOffset: Math.floor(Math.random() * 10)
                    });
                }

                // Create service labels at different depths
                const labelAnchors = [];
                for (let i = 0; i < services.length; i++) {
                    const t = (i + 1) / (services.length + 1);
                    const z = -tunnelDepth / 2 + t * tunnelDepth;
                    const radiusMultiplier = 1 - t * 0.7;
                    const labelRadius = baseRadius * radiusMultiplier * 1.3;

                    const anchor = new THREE.Object3D();
                    anchor.position.set(0, 0, z);
                    dataGroup.add(anchor);

                    labelAnchors.push({
                        anchor: anchor,
                        service: services[i],
                        description: descriptions[services[i]],
                        z: z,
                        radius: labelRadius
                    });
                }

                // Create service labels
                function makeLabelTexture(text) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 512;
                    canvas.height = 128;
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, 512, 128);
                    ctx.font = 'bold 20px "Segoe UI", Arial, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    ctx.shadowColor = 'rgba(116, 54, 187, 1)';
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(text, 256, 64);

                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(text, 256, 64);

                    const texture = new THREE.CanvasTexture(canvas);
                    texture.needsUpdate = true;
                    return texture;
                }

                const labelEntries = [];
                labelAnchors.forEach((anchorData, idx) => {
                    const texture = makeLabelTexture(anchorData.service);
                    const material = new THREE.SpriteMaterial({
                        map: texture,
                        transparent: true
                    });
                    material.depthTest = false;
                    const sprite = new THREE.Sprite(material);
                    const scale = 1 - (idx / labelAnchors.length) * 0.5;
                    const baseScale = isMobile ? 0.7 : 1; // Smaller on mobile
                    sprite.scale.set(6 * scale * baseScale, 1.6 * scale * baseScale, 1);
                    sprite.renderOrder = 999;
                    scene.add(sprite);
                    labelEntries.push({
                        sprite: sprite,
                        anchor: anchorData.anchor,
                        service: anchorData.service,
                        description: anchorData.description,
                        index: idx,
                        radius: anchorData.radius
                    });
                });

                // Click and touch interaction
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();

                function onClick(ev) {
                    try {
                        const rect = canvas.getBoundingClientRect();
                        const clientX = ev.clientX || (ev.touches && ev.touches[0].clientX);
                        const clientY = ev.clientY || (ev.touches && ev.touches[0].clientY);

                        mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
                        mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
                        raycaster.setFromCamera(mouse, camera);
                        const intersects = raycaster.intersectObjects(labelEntries.map(le => le.sprite), true);
                        if (intersects.length) {
                            const obj = intersects[0].object;
                            const entry = labelEntries.find(le => le.sprite === obj);
                            if (entry) showPanel(entry.service, entry.description);
                        }
                    } catch (e) {
                        console.error('Click handler error', e);
                    }
                }
                canvas.addEventListener('click', onClick);
                canvas.addEventListener('touchend', onClick);

                function showPanel(title, text) {
                    const panel = document.getElementById('info-panel');
                    const content = document.getElementById('info-content');
                    content.innerHTML = `<h2>${title}</h2><p>${text}</p>`;
                    panel.classList.add('visible');
                    panel.setAttribute('aria-hidden', 'false');
                }

                function closePanel() {
                    const panel = document.getElementById('info-panel');
                    panel.classList.remove('visible');
                    panel.setAttribute('aria-hidden', 'true');
                }
                window.closePanel = closePanel;

                // Animation loop
                let time = 0;

                function animate() {
                    requestAnimationFrame(animate);
                    time += 0.01;

                    // Move camera forward through tunnel
                    dataGroup.position.z = Math.sin(time * 0.3) * 3;

                    // Animate data packets
                    dataPackets.forEach(packet => {
                        packet.progress += packet.speed;
                        if (packet.progress >= 1) {
                            packet.progress = 0;
                            packet.streamIndex = Math.floor(Math.random() * streamCount);
                        }

                        const segmentStart = packet.streamIndex * segmentsPerStream + packet.segmentOffset;
                        const idx1 = Math.floor(packet.progress * (segmentsPerStream - packet.segmentOffset - 1)) + segmentStart;
                        const idx2 = Math.min(idx1 + 1, allNodes.length - 1);

                        if (allNodes[idx1] && allNodes[idx2]) {
                            const localProgress = (packet.progress * (segmentsPerStream - packet.segmentOffset - 1)) % 1;
                            const pos = allNodes[idx1].position.clone().lerp(allNodes[idx2].position, localProgress);
                            packet.mesh.position.copy(pos);

                            const scale = 1 + Math.sin(time * 5 + packet.progress * 10) * 0.3;
                            packet.mesh.scale.setScalar(scale);
                        }
                    });

                    // Pulse nodes
                    allNodes.forEach((node, idx) => {
                        const pulse = 0.8 + Math.sin(time * 2 + idx * 0.1) * 0.2;
                        node.mesh.scale.setScalar(pulse);
                    });

                    // Position labels in circular pattern around their depth
                    labelEntries.forEach((entry, idx) => {
                        const world = new THREE.Vector3();
                        entry.anchor.getWorldPosition(world);

                        const speed = isMobile ? 0.25 : 0.1;
                        const angle = (idx / labelEntries.length) * Math.PI * 2 + time * speed;


                        // Adjust limits based on screen size
                        const maxX = isMobile ? 3.2 : 5;
                        const maxY = isMobile ? 1.8 : 2.8;

                        const x = Math.cos(angle) * maxX;
                        const y = Math.sin(angle) * maxY;

                        entry.sprite.position.set(
                            x,
                            y,
                            camera.position.z - 6
                        );

                        entry.sprite.quaternion.copy(camera.quaternion);
                    });

                    // Animate lights
                    light1.position.x = Math.cos(time * 0.4) * 20;
                    light1.position.y = Math.sin(time * 0.4) * 20;

                    light2.position.x = Math.cos(time * 0.3 + Math.PI) * 15;
                    light2.position.y = Math.sin(time * 0.3 + Math.PI) * 15;

                    renderer.render(scene, camera);
                }
                animate();

                window.addEventListener('resize', () => {
                    const wasMobile = isMobile;
                    isMobile = window.innerWidth < 768;

                    camera.aspect = window.innerWidth / window.innerHeight;

                    // Update FOV and camera position on orientation/size change
                    if (wasMobile !== isMobile) {
                        camera.fov = isMobile ? 90 : 75;
                        camera.position.z = isMobile ? 35 : 30;
                    }

                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);

                    // Update label scales
                    labelEntries.forEach((entry, idx) => {
                        const scale = 1 - (idx / labelEntries.length) * 0.5;
                        const baseScale = isMobile ? 0.85 : 1;
                        entry.sprite.scale.set(6 * scale * baseScale, 1.6 * scale * baseScale, 1);
                    });
                });

            } catch (err) {
                console.error('Fatal error:', err);
            }
        })();
    </script>
</body>

</html>
