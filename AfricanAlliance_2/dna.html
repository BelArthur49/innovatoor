<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>DNA Helix — Top Rainbow Rungs (Fixed)</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #000;
            font-family: system-ui, Arial;
        }
        
        .dna-header {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            background: #000;
        }
        
        #dna-canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: transparent;
        }
        
        .sprite-hint {
            position: absolute;
            left: 12px;
            bottom: 10px;
            font-size: 12px;
            color: #ddd;
            opacity: .85;
            z-aa: 12;
            pointer-events: none;
        }
        
        .info-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.75);
            border-radius: 12px;
            padding: 22px 26px;
            color: #fff;
            z-aa: 60;
            max-width: 820px;
            width: calc(100% - 40px);
            box-shadow: 0 14px 60px rgba(0, 0, 0, 0.6);
            opacity: 0;
            pointer-events: none;
            transition: opacity .25s, transform .25s;
            background-size: cover;
            background-position: center;
            backdrop-filter: blur(6px);
        }
        
        .info-panel.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translate(-50%, -50%) scale(1);
        }
        
        .info-overlay {
            background: linear-gradient(to bottom right, rgba(0, 0, 0, 0.45), rgba(0, 0, 0, 0.65));
            padding: 18px;
            border-radius: 10px;
        }
        
        .info-panel h2 {
            margin: 0 0 8px 0;
            font-size: 1.35rem;
            color: #fff;
        }
        
        .info-panel p {
            margin: 0;
            color: #fff;
            line-height: 1.45;
        }
        
        .info-panel .close-btn {
            position: absolute;
            top: 8px;
            right: 10px;
            background: none;
            border: 0;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
        }
        
        .error-overlay {
            position: fixed;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.95));
            color: #fff;
            z-aa: 9999;
            padding: 20px;
            text-align: center;
            font-size: 15px;
            visibility: hidden;
            opacity: 0;
            transition: opacity .25s, visibility .25s;
        }
        
        .error-overlay.visible {
            visibility: visible;
            opacity: 1;
        }
        
        @media(max-width:768px) {
            .info-panel {
                max-width: 92%;
                padding: 14px;
            }
            .info-panel h2 {
                font-size: 1.05rem;
            }
        }
    </style>
</head>

<body>
    <div class="dna-header" id="dnaHeader">
        <canvas id="dna-canvas" aria-label="DNA visualization"></canvas>
        <div class="sprite-hint">Click labels inside the helix</div>

        <div class="info-panel" id="info-panel" role="dialog" aria-hidden="true">
            <button class="close-btn" onclick="closePanel()" aria-label="Close">×</button>
            <div class="info-overlay" id="info-content"></div>
        </div>
    </div>

    <div id="fatalError" class="error-overlay" role="alert">
        <div>
            <strong>Rendering error</strong>
            <div id="fatalErrorMsg" style="margin-top:10px;opacity:0.9;font-size:14px">An unexpected error occurred. Open the console for details.</div>
        </div>
    </div>

    <!-- Three.js r128 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        (function() {
            // Wrap everything in try/catch so user never sees a silent black screen.
            try {
                // ---------- CONFIG / DATA ----------
                const labels = ["LOREM", "Ipsum", "Dolor", "Sit", "Consectetur", "Adipiscing", "Elit"];
                const descriptions = {
                    LOREM: "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
                    Ipsum: "Ipsum — placeholder description for this label.",
                    Dolor: "Dolor — placeholder description for this label.",
                    Sit: "Sit — placeholder description for this label.",
                    Consectetur: "Consectetur — placeholder description for this label.",
                    Adipiscing: "Adipiscing — placeholder description for this label.",
                    Elit: "Elit — placeholder description for this label."
                };
                // Per-label images (public unsplash, safe for demos)
                const labelImages = {
                    LOREM: "https://images.unsplash.com/photo-1522202176988-66273c2fd55f?q=80&w=1600&auto=format&fit=crop",
                    Ipsum: "https://images.unsplash.com/photo-1501785888041-af3ef285b470?q=80&w=1600&auto=format&fit=crop",
                    Dolor: "https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?q=80&w=1600&auto=format&fit=crop",
                    Sit: "https://images.unsplash.com/photo-1496307042754-b4aa456c4a2d?q=80&w=1600&auto=format&fit=crop",
                    Consectetur: "https://images.unsplash.com/photo-1496307042754-b4aa456c4a2d?q=80&w=1600&auto=format&fit=crop",
                    Adipiscing: "https://images.unsplash.com/photo-1469474968028-56623f02e42e?q=80&w=1600&auto=format&fit=crop",
                    Elit: "https://images.unsplash.com/photo-1504384308090-c894fdcc538d?q=80&w=1600&auto=format&fit=crop"
                };

                const RAINBOW_RUNGS_COUNT = 12; // top-most 4 rungs will become rainbow

                // ---------- THREE.JS SETUP ----------
                const canvas = document.getElementById('dna-canvas');
                if (!canvas) throw new Error('Canvas element not found');

                const scene = new THREE.Scene();
                scene.background = null; // allow CSS background to show
                const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 0, 18);

                const renderer = new THREE.WebGLRenderer({
                    canvas,
                    antialias: true,
                    alpha: true
                });
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x000000, 0);

                // lights
                scene.add(new THREE.AmbientLight(0xffffff, 0.45));
                const dir = new THREE.DirectionalLight(0xffffff, 0.8);
                dir.position.set(10, 10, 10);
                scene.add(dir);

                const dnaGroup = new THREE.Group();
                scene.add(dnaGroup);

                // ---------- HELIX PARAMETERS ----------
                const SEGMENTS = 160;
                const HELIX_HEIGHT = 16;
                const RADIUS = 3.0;
                const TURNS = 4.2;
                const RUNG_EVERY = 4;
                const LABEL_SCALE = 2.4;

                // ---------- MATERIALS ----------
                const backboneMatA = new THREE.MeshPhongMaterial({
                    color: 0xdddddd,
                    shininess: 40
                });
                const backboneMatB = new THREE.MeshPhongMaterial({
                    color: 0x999999,
                    shininess: 30
                });
                const rungRed = new THREE.MeshPhongMaterial({
                    color: 0xff3333
                });
                const rungBlue = new THREE.MeshPhongMaterial({
                    color: 0x3388ff
                });

                // rainbow texture for cylinders
                function makeRainbowTexture(w = 1024, h = 64) {
                    const c = document.createElement('canvas');
                    c.width = w;
                    c.height = h;
                    const ctx = c.getContext('2d');
                    const grad = ctx.createLinearGradient(0, 0, w, 0);
                    grad.addColorStop(0.00, "#E40303");
                    grad.addColorStop(0.16, "#FF8C00");
                    grad.addColorStop(0.33, "#FFED00");
                    grad.addColorStop(0.50, "#008026");
                    grad.addColorStop(0.66, "#004DFF");
                    grad.addColorStop(0.83, "#750787");
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, w, h);
                    const tex = new THREE.CanvasTexture(c);
                    tex.needsUpdate = true;
                    return tex;
                }
                const rainbowTex = makeRainbowTexture();
                const rainbowMat = new THREE.MeshPhongMaterial({
                    map: rainbowTex
                });

                // rainbow color stops for sphere recolor interpolation
                const rainbowStops = [{
                    t: 0.00,
                    color: "#E40303"
                }, {
                    t: 0.16,
                    color: "#FF8C00"
                }, {
                    t: 0.33,
                    color: "#FFED00"
                }, {
                    t: 0.50,
                    color: "#008026"
                }, {
                    t: 0.66,
                    color: "#004DFF"
                }, {
                    t: 0.83,
                    color: "#750787"
                }];

                function parseColor(hex) {
                    const c = new THREE.Color();
                    c.setStyle(hex);
                    return c;
                }
                const rainbowColors = rainbowStops.map(s => ({
                    t: s.t,
                    c: parseColor(s.color)
                }));

                function rainbowColorForT(t) {
                    if (t <= 0) return rainbowColors[0].c.clone();
                    if (t >= 1) return rainbowColors[rainbowColors.length - 1].c.clone();
                    let i = 0;
                    while (i < rainbowColors.length - 1 && t > rainbowColors[i + 1].t) i++;
                    const a = rainbowColors[i],
                        b = rainbowColors[i + 1];
                    const local = (t - a.t) / (b.t - a.t);
                    return a.c.clone().lerp(b.c, local);
                }

                // ---------- BUILD HELIX ----------
                const anchors = []; // { anchor, angle, y }
                const rungGroups = []; // per-anchor arrays of meshes (for easy removal)
                const backboneDots = []; // {mesh, y}
                for (let i = 0; i < SEGMENTS; i++) {
                    const t = i / SEGMENTS;
                    const y = (t - 0.5) * HELIX_HEIGHT;
                    const angle = t * Math.PI * 2 * TURNS;
                    const xA = Math.cos(angle) * RADIUS,
                        zA = Math.sin(angle) * RADIUS;
                    const xB = Math.cos(angle + Math.PI) * RADIUS,
                        zB = Math.sin(angle + Math.PI) * RADIUS;

                    // backbone dots
                    const sA = new THREE.Mesh(new THREE.SphereGeometry(0.12, 12, 12), backboneMatA.clone());
                    sA.position.set(xA, y, zA);
                    dnaGroup.add(sA);
                    backboneDots.push({
                        mesh: sA,
                        y
                    });
                    const sB = new THREE.Mesh(new THREE.SphereGeometry(0.12, 12, 12), backboneMatB.clone());
                    sB.position.set(xB, y, zB);
                    dnaGroup.add(sB);
                    backboneDots.push({
                        mesh: sB,
                        y
                    });

                    // rung halves every RUNG_EVERY
                    if (i % RUNG_EVERY === 0) {
                        const midX = (xA + xB) / 2,
                            midZ = (zA + zB) / 2;
                        const distance = Math.hypot(xB - xA, zB - zA);
                        const half = distance / 2;
                        const created = [];

                        const cyl = new THREE.CylinderGeometry(0.06, 0.06, half, 12);

                        const r = new THREE.Mesh(cyl, rungRed.clone());
                        r.position.set(xA + (midX - xA) / 2, y, zA + (midZ - zA) / 2);
                        r.setRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), (new THREE.Vector3(midX - xA, 0, midZ - zA)).normalize()));
                        dnaGroup.add(r);
                        created.push(r);

                        const b = new THREE.Mesh(cyl, rungBlue.clone());
                        b.position.set(midX + (xB - midX) / 2, y, midZ + (zB - midZ) / 2);
                        b.setRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), (new THREE.Vector3(xB - midX, 0, zB - midZ)).normalize()));
                        dnaGroup.add(b);
                        created.push(b);

                        const anchor = new THREE.Object3D();
                        anchor.position.set(midX, y, midZ);
                        dnaGroup.add(anchor);
                        anchors.push({
                            anchor,
                            angle,
                            y
                        });
                        rungGroups.push(created);
                    }
                }

                if (anchors.length === 0) throw new Error('No anchors created — helix parameters may be invalid.');

                // ---------- determine top-most anchors for rainbow ----------
                const ordered = anchors.map((v, i) => ({
                    i,
                    y: v.y
                })).sort((a, b) => b.y - a.y);
                const topCount = Math.min(RAINBOW_RUNGS_COUNT, ordered.length);
                const topIndices = ordered.slice(0, topCount).map(o => o.i).sort((a, b) => a - b);

                // compute rainbow zone min/max Y
                let rMin = Infinity,
                    rMax = -Infinity;
                topIndices.forEach(i => {
                    const a = anchors[i];
                    if (!a) return;
                    rMin = Math.min(rMin, a.y - 0.5);
                    rMax = Math.max(rMax, a.y + 0.5);
                });
                if (!isFinite(rMin)) {
                    rMin = 0;
                    rMax = 0;
                }

                // replace selected rung halves with rainbow cylinder
                topIndices.forEach(idx => {
                    const a = anchors[idx];
                    if (!a) return;
                    // remove old halves if present
                    const group = rungGroups[idx] || [];
                    group.forEach(m => {
                        try {
                            if (m && m.parent) m.parent.remove(m);
                        } catch (e) {}
                    });
                    rungGroups[idx] = [];

                    // compute geometry for single rainbow cylinder
                    const angle = a.angle;
                    const xA = Math.cos(angle) * RADIUS,
                        zA = Math.sin(angle) * RADIUS;
                    const xB = Math.cos(angle + Math.PI) * RADIUS,
                        zB = Math.sin(angle + Math.PI) * RADIUS;
                    const midX = (xA + xB) / 2,
                        midZ = (zA + zB) / 2;
                    const distance = Math.hypot(xB - xA, zB - zA);
                    const cylGeom = new THREE.CylinderGeometry(0.12, 0.12, distance, 32);
                    const rainbow = new THREE.Mesh(cylGeom, rainbowMat.clone());
                    rainbow.position.set(midX, a.y, midZ);
                    const dir = new THREE.Vector3(xB - xA, 0, zB - zA).normalize();
                    rainbow.setRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir));
                    rainbow.renderOrder = 50;
                    dnaGroup.add(rainbow);
                    rungGroups[idx].push(rainbow);
                });

                // recolor backbone spheres inside rainbow zone
                (function recolor() {
                    const zone = rMax - rMin;
                    backboneDots.forEach(entry => {
                        try {
                            const y = entry.y;
                            if (y >= rMin && y <= rMax && zone > 1e-6) {
                                const t = (y - rMin) / zone;
                                const color = rainbowColorForT(t);
                                entry.mesh.material = new THREE.MeshPhongMaterial({
                                    color: color
                                });
                            } else {
                                // outside zone defaults
                                const c = entry.mesh.position.x >= 0 ? 0xdddddd : 0x999999;
                                entry.mesh.material = new THREE.MeshPhongMaterial({
                                    color: c,
                                    shininess: 30
                                });
                            }
                        } catch (e) {
                            console.warn('recolor error', e);
                        }
                    });
                })();

                // ---------- labels (non-rotating sprites) ----------
                function makeLabelTexture(text) {
                    const cw = 512,
                        ch = 128;
                    const c = document.createElement('canvas');
                    c.width = cw;
                    c.height = ch;
                    const ctx = c.getContext('2d');
                    ctx.clearRect(0, 0, cw, ch);
                    ctx.font = '700 40px "Arial", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = 'rgba(255,255,255,1)';
                    ctx.shadowColor = 'rgba(0,0,0,0.6)';
                    ctx.shadowBlur = 8;
                    ctx.fillText(text, cw / 2, ch / 2 + 2);
                    const tex = new THREE.CanvasTexture(c);
                    tex.needsUpdate = true;
                    return tex;
                }

                // spread labels evenly across anchors
                const anchorCount = anchors.length;
                const step = Math.max(1, Math.floor(anchorCount / labels.length));
                const anchorsToUse = [];
                for (let i = 0; i < labels.length; i++) anchorsToUse.push(Math.min(anchorCount - 1, i * step));

                const labelEntries = [];
                anchorsToUse.forEach((anchorIdx, idx) => {
                    const info = anchors[anchorIdx];
                    if (!info) return;
                    const tex = makeLabelTexture(labels[idx]);
                    const mat = new THREE.SpriteMaterial({
                        map: tex,
                        transparent: true
                    });
                    mat.depthTest = false;
                    const sprite = new THREE.Sprite(mat);
                    sprite.scale.set(1.8 * LABEL_SCALE, 1.0 * LABEL_SCALE, 1);
                    sprite.renderOrder = 999;
                    scene.add(sprite);
                    labelEntries.push({
                        sprite,
                        anchor: info.anchor,
                        label: labels[idx],
                        description: descriptions[labels[idx]]
                    });
                });

                // ---------- raycast for clicks ----------
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();

                function onClick(ev) {
                    try {
                        const rect = canvas.getBoundingClientRect();
                        mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
                        mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
                        raycaster.setFromCamera(mouse, camera);
                        const intersects = raycaster.intersectObjects(labelEntries.map(le => le.sprite), true);
                        if (intersects.length) {
                            const obj = intersects[0].object;
                            const entry = labelEntries.find(le => le.sprite === obj);
                            if (entry) showPanel(entry.label, entry.description, labelImages[entry.label] || '');
                        }
                    } catch (e) {
                        console.error('click handler error', e);
                    }
                }
                canvas.addEventListener('click', onClick);

                // ---------- info panel ----------
                function showPanel(title, text, imageUrl) {
                    const panel = document.getElementById('info-panel');
                    const content = document.getElementById('info-content');
                    if (imageUrl) panel.style.backgroundImage = `url("${imageUrl}")`;
                    else panel.style.backgroundImage = '';
                    content.innerHTML = `<h2>${title}</h2><p>${text}</p>`;
                    panel.classList.add('visible');
                    panel.setAttribute('aria-hidden', 'false');
                }

                function closePanel() {
                    const panel = document.getElementById('info-panel');
                    panel.classList.remove('visible');
                    panel.setAttribute('aria-hidden', 'true');
                    setTimeout(() => {
                        panel.style.backgroundImage = '';
                    }, 260);
                }
                window.closePanel = closePanel;

                // ---------- animation loop ----------
                let tt = 0;

                function animate() {
                    requestAnimationFrame(animate);
                    tt += 0.009;
                    dnaGroup.rotation.y += 0.0025;
                    dnaGroup.position.y = Math.sin(tt * 0.7) * 0.35;

                    // position non-rotating labels to follow anchors (but face camera)
                    labelEntries.forEach(entry => {
                        const world = new THREE.Vector3();
                        entry.anchor.getWorldPosition(world);
                        // inward offset so label sits inside helix
                        const inward = new THREE.Vector3(0, world.y, 0).sub(world).normalize().multiplyScalar(0.8);
                        const pos = world.clone().add(inward);
                        pos.y += 0.08 * Math.sin(tt * 1.1 + entry.sprite.position.x);
                        entry.sprite.position.copy(pos);
                        // face camera
                        entry.sprite.quaternion.copy(camera.quaternion);
                        entry.sprite.renderOrder = 999;
                        entry.sprite.material.depthTest = false;
                    });

                    renderer.render(scene, camera);
                }
                animate();

                // handle resize
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });

                // debug: quick console note
                console.log('DNA helix started — anchors:', anchors.length, 'rungs groups:', rungGroups.length);

            } catch (err) {
                console.error('Fatal error while building DNA scene:', err);
                const overlay = document.getElementById('fatalError');
                const msg = document.getElementById('fatalErrorMsg');
                msg.textContent = String(err && err.message ? err.message : err);
                overlay.classList.add('visible');
            }
        })();
    </script>
</body>

</html>